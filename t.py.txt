import numpy as np

def as_cell_struct(data):
    if not isinstance(data, list):
        data = [x for x in np.nditer(data)]
    return data
-------------
import pandas as pd
import numpy as np

def getValueFromLookupTable(lookup_table_name, out_col_name, val_if_nan, lkp_filter, upper_bound_incl=0):
    # Load the lookup table (assuming it's a CSV file)
    lookup_table = pd.read_csv(lookup_table_name)

    # Add double quotes for eval
    lkp_filter[0]['inputVal'] = [str(x).replace("'", "''") for x in lkp_filter[0]['inputVal']]
    out_val = [None] * len(lkp_filter[0]['inputVal'])

    # First, get the output column
    out_column = lookup_table[out_col_name]

    logical_idx = np.ones((len(lookup_table), len(lkp_filter[0]['inputVal'])), dtype=bool)

    # Loop across the filters and build up the index vector idx by "and"
    for i_field in range(len(lkp_filter)):
        if 'maxValField' in lkp_filter[i_field] and isinstance(lkp_filter[i_field]['maxValField'][0], str):
            input_min_val = lookup_table[lkp_filter[i_field]['minValField'][0]]
            input_max_val = lookup_table[lkp_filter[i_field]['maxValField'][0]]
            input_val = lkp_filter[i_field]['inputVal']
            for i_input in range(len(lkp_filter[0]['inputVal'])):
                if np.nansum(upper_bound_incl):
                    logical_idx[:, i_input] &= (input_min_val < input_val[i_input]) & (input_val[i_input] <= input_max_val)
                else:
                    logical_idx[:, i_input] &= (input_min_val <= input_val[i_input]) & (input_val[i_input] < input_max_val)
        else:
            input_field = lookup_table[lkp_filter[i_field]['minValField'][0]]
            input_val = lkp_filter[i_field]['inputVal']
            for i_input in range(len(lkp_filter[0]['inputVal'])):
                logical_idx[:, i_input] &= input_field.str.lower() == input_val[i_input].lower()

    # Now apply the filter
    for i_input in range(len(lkp_filter[0]['inputVal'])):
        idx = np.argmax(logical_idx[:, i_input])
        lkp_val = out_column.iloc[idx]

        if pd.isna(lkp_val):
            lkp_val = np.nan
        out_val[i_input] = lkp_val

    out_val = [val_if_nan if pd.isna(x) else x for x in out_val]

    if all(isinstance(x, (int, float)) for x in out_val):
        out_val = np.array(out_val)

    return out_val
----------------------
import numpy as np

def nvl(data, newVal):
    if newVal is None:
        return
    
    if isinstance(data, str):
        data = [data]
    else:
        data = as_cell_struct(data)
    
    for iData in range(len(data)):
        if np.isnan(data[iData]):
            data[iData] = newVal
    
    if all(isinstance(item, (int, float)) for item in data):
        data = np.array(data)
    
    return data

---------------
import numpy as np

def rabl_getPeerRank(ratio_in, peerID_in, ratioName_in, peerDataTable):
    ratio_in = ratio_in[0]  # value from the newest statement only
    if np.isnan(ratio_in):
        val_out = np.nan
        return val_out

    valQ1 = 0.01 * getValueFromLookupTable(peerDataTable, ratioName_in + 'Q1', 0, {'minValField': ['PeerID'], 'inputVal': [str(peerID_in)]})
    valQ2 = 0.01 * getValueFromLookupTable(peerDataTable, ratioName_in + 'Q2', 0, {'minValField': ['PeerID'], 'inputVal': [str(peerID_in)]})
    valQ3 = 0.01 * getValueFromLookupTable(peerDataTable, ratioName_in + 'Q3', 0, {'minValField': ['PeerID'], 'inputVal': [str(peerID_in)]})

    # if q1=q2 and q1<q3 then q1-  example: 3 3 4
    # if q1=q2 and q1>q3 then q1+  example: 4 4 3
    # if q1=q2 and q1=q3 then q1+  example: 2 2 2
    if valQ1 == valQ2:
        if valQ1 < valQ3:
            valQ1 = valQ1 * 0.99
        else:
            valQ1 = valQ1 * 1.01

    # if q2=q3 and q1<q3 then q3+  example: 3 4 4
    # if q2=q3 and q1>q3 then q3-  example: 4 3 3
    # if q2=q3 and q1=q3 then q3-  example: 2 2 2
    if valQ2 == valQ3:
        if valQ1 < valQ3:
            valQ3 = valQ3 * 1.01
        else:
            valQ3 = valQ3 * 0.99

    if ratio_in > valQ2:
        val_r = (valQ2 - ratio_in) / (max(valQ1, valQ3) - valQ2)
    else:
        val_r = (valQ2 - ratio_in) / (min(valQ1, valQ3) - valQ2)

    # Denominator in above fractions cannot be zero:
    if np.isnan(val_r) or np.isinf(val_r):
        val_out = np.nan
        return val_out

    # Standard Rank:
    if (valQ3 > valQ1 and ratio_in > valQ2) or (valQ3 < valQ1 and ratio_in < valQ2):
        val_out = 2 ** (val_r - 1)
    else:
        val_out = 1 - 2 ** (val_r - 1)

    return val_out
