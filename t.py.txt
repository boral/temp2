import numpy as np
from scipy.stats import norm
from scipy.optimize import brentq
from joblib import Parallel, delayed

class PT_variN:
    def __init__(self, df, rho, theta):
        self.N = df['gcdu_id'].values
        self.T = len(self.N)
        self.rho = rho
        self.theta = theta
        self.Nmax = np.max(self.N)
        self.mu = np.zeros(self.T)
        self.sigma = self._calculate_sigma()

    def _calculate_sigma(self):
        i, j = np.indices((self.T, self.T))
        return np.power(self.theta, np.abs(i - j))

    def sum_of_defaults(self, PD):
        rng = np.random.default_rng()
        idiosyncratic_full_box = rng.normal(size=(self.Nmax, self.T))
        systematic_box = np.tile(rng.multivariate_normal(self.mu, self.sigma, 1), (self.Nmax, 1))
        
        for j, k in enumerate(self.N):
            idiosyncratic_full_box[k:, j] = np.nan
            systematic_box[k:, j] = np.nan
        
        asset_return = np.sqrt(self.rho) * systematic_box + np.sqrt(1 - self.rho) * idiosyncratic_full_box
        defaults = asset_return < norm.ppf(PD)
        return np.sum(defaults)

    def simulation(self, PD, num_simulation):
        return np.array([self.sum_of_defaults(PD) for _ in range(num_simulation)])

    def obj_func(self, PD, num_simulation, N_defaults, confidence_level):
        alpha = 1 - np.mean(self.simulation(PD, num_simulation) <= N_defaults)
        return alpha - confidence_level

    def calculate_pd(self, num_simulation, N_defaults, confidence_level):
        return brentq(self.obj_func, a=1e-7, b=1 - 1e-7, args=(num_simulation, N_defaults, confidence_level))

# Parallel simulation execution
def simulate_and_calculate_pd(params):
    X, PD, n_defaults, confidence_level = params
    return X.calculate_pd(500, n_defaults, confidence_level)

# Initialize PT_variN object for each month and simulate in parallel
lradr_data_grouped = lradr_data.groupby('cohort_month')
results = Parallel(n_jobs=-1)(
    delayed(simulate_and_calculate_pd)([PT_variN(df, 0.18, 0.7), 500, n_defaults, cl])
    for cl, (i, df) in zip([0.5, 0.85], lradr_data_grouped)
)

# Extract results
pd_best_estimate_final = np.mean([res[0] for res in results])
pd_conservative_final = np.mean([res[1] for res in results]) + np.std([res[1] for res in results])
